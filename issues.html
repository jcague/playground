<html>
<head>
<meta charset="utf-8">
<script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
<script src="https://webrtc.github.io/samples/src/js/third_party/graph.js"></script>
<script src="test-assert.js"></script>
<script src="draw-graphs.js"></script>
<style>
video {
  width: 320px;
}
.container {
    display: inline-flex;
}
</style>
</head>
<body>
<div id="local">
  <h2>Local Video</h2>
</div>
<div id="remotes">
  <h2>Remote Videos</h2>
</div>
<div id="controls">
    <h2>Encoding Info</h2>
    <span id="encodingInfo"></span>
</div>
<div id="issues">
    <h2>Issues</h2>
    <div id="issue1">
        <span>
            Wait 7 seconds until everything is loaded.<br/>
            Click on each step and wait some seconds to let changes be applied:<br/>
            Reload the page to test each issue.
        </span>
        <h3>Issue 1</h3>
        <p>
            Chrome 111+: When scaling down the resolution, if I pass the bitrate we start seeing many quality limitation reports.
        </p>
        <button class="scale" data-scale="2" data-maxBitrate="200000" data-active="true">1. Enable encoding, set scaleResolutionDownBy=2 maxBitrate=200kbps.</button>
        <button class="scale" data-scale="1" data-active="false">2. Disable encoding and change scaleResolutionDownBy=1.</button>
        <span>Result: qualityLimitationDurations(BW) increases</span>
        <h4>Fix to Issue 1</h4>
        <button class="scale" data-scale="2" data-maxBitrate="200000" data-active="true">1. Enable encoding, set scaleResolutionDownBy=2 maxBitrate=200kbps.</button>
        <button class="scale" data-active="false">2. Disable encoding and unset scaleResolutionDownBy and maxBitrate.</button>
        <span>Result: qualityLimitationDurations(BW) does not increase</span>
        <h3>Issue 2</h3>
        <p>
            Chrome 111+: If the maxBitrate is lower than the bitrate required for the resolution, Chrome tab crashes.
        </p>
        <button class="scale" data-scale="1" data-maxBitrate="200000" data-active="true">1. Enable encoding, set scaleResolutionDownBy=1 and maxBitrate=200kbps.</button>
        <span>Result: Chrome tab crashes</span>
        <h3>Issue 3</h3>
        <p>
            Chrome 111+: If we don't set the maxBitrate and use only a single spatial layer the bitrate increases to 1.5Mbps.
        </p>
        <button class="scale" data-scale="2"  data-active="true">1. Enable encoding, set scaleResolutionDownBy=2 (width=320,height=240).</button>
        <span>Result: Bitrate increases to 1.5Mbps. More bitrate than what we see when scaleResolutionDownBy is set to 1.</span>
        <h4>Fix to Issue 3</h4>
        <button class="scale" data-scale="2"  data-maxBitrate="172000" data-active="true">1. Enable encoding, set scaleResolutionDownBy=2 (width=320,height=240) and maxBitrate.</button>
        <span>Result: Bitrate decreases to the expected value (as calculated in <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/modules/video_coding/codecs/vp9/svc_config.cc;l=145;drc=e2587664bf8ad704d7bee1989e9186729ef950e0">svc_config.cc</a>).</span>
    </div>
</div>
<script>
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
const SDPUtils = adapter.sdp;
const searchParameters = new URLSearchParams(window.location.search);

const pc1 = new RTCPeerConnection({sdpSemantics: 'unified-plan'});
const pc2 = new RTCPeerConnection({sdpSemantics: 'unified-plan'});
pc1.onicecandidate = (e) => pc2.addIceCandidate(e.candidate);
pc2.onicecandidate = (e) => pc1.addIceCandidate(e.candidate);
pc2.ontrack = (e) => show(e.streams[0], true);

const rids = ['0'];
const video = {width: 640, height: 480};
const scalabilityMode = searchParameters.get('scalabilityMode') || 'L3T3_KEY';
const videoCodec = 'vp9';

const remb = searchParameters.has('remb');
navigator.mediaDevices.getUserMedia({video})
.then((stream) => {
    const transceiver = pc1.addTransceiver(stream.getVideoTracks()[0], {
        streams: [stream],
        sendEncodings: rids.map(rid => ({rid, scalabilityMode})),
    });
    document.getElementById('encodingInfo').innerText = 'Encodings: ' + JSON.stringify(rids.map(rid => ({rid, scalabilityMode})), null, 2);
    const codecs = RTCRtpSender.getCapabilities('video').codecs
        .filter(c => {
            return c.mimeType.toLowerCase() === 'video/' + videoCodec;
        })
        .filter(c => {
            return !searchParameters.has('profile') || c.sdpFmtpLine.includes(searchParameters.get('profile'));
        });
    transceiver.setCodecPreferences(codecs);
    show(stream, false);
    return pc1.createOffer();
})
.then((offer) => {
    return Promise.all([
        pc1.setLocalDescription(offer),
        pc2.setRemoteDescription(offer),
    ]);
})
.then(() => pc2.createAnswer())
.then(answer => {
    return Promise.all([
        pc2.setLocalDescription(answer),
        pc1.setRemoteDescription(answer),
    ]);
})
.then(() => {
    const buttons = document.getElementsByClassName('scale');
    for (let i = 0; i < buttons.length; i++) {
        const button = buttons[i];
        button.disabled = true;
        button.onclick = () => {
            let scale = event.target.getAttribute('data-scale');
            let maxBitrate = event.target.getAttribute('data-maxBitrate');
            let active = event.target.getAttribute('data-active');

            active = active !== null ? active === 'true' : undefined;
            scale = scale !== null ? parseFloat(scale) : undefined;
            maxBitrate = maxBitrate !== null ? parseInt(maxBitrate) : undefined;

            console.log('scale', scale, 'active', active, 'maxBitrate', maxBitrate);
            setParameters(scale, active, maxBitrate);
        };
        setTimeout(() => {
            button.disabled = false;
        }, 7000);
    }

    window.setInterval(() => {
        draw(pc1, pc2);
    }, 2000);
})
.catch(e => console.error(e));

async function setParameters(scaleResolutionDownBy, active, maxBitrate) {
    const transceiver = pc1.getTransceivers()[0];
    const params = transceiver.sender.getParameters();
    if (scaleResolutionDownBy !== undefined) {
        params.encodings[0].scaleResolutionDownBy = scaleResolutionDownBy;
    }
    if (maxBitrate !== undefined) {
        params.encodings[0].maxBitrate = maxBitrate;
    }
    if (active !== undefined) {
        params.encodings[0].active = active;
    }
    document.getElementById('encodingInfo').innerText = 'Encodings: ' + JSON.stringify(params.encodings, null, 2);
    await transceiver.sender.setParameters(params);
}
</script>
</body>
</html>
